# -*- coding: utf-8 -*-
"""Basic_Transformer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1en7aksqJU9dq0e_k4LLxym8veHXwq3Yc
"""

import torch
import torch.nn.functional as F
import torch.nn as nn
import torch.nn.functional as F

class Ultimus(nn.Module):
    def __init__(self,device):
        super(UltimusBlock, self).__init__()
        
        self.fc_k=nn.Linear(48,8)
        self.fc_q=nn.Linear(48,8)
        self.fc_v=nn.Linear(48,8)
        self.scale=torch.sqrt(torch.FloatTensor([8])).to(device)
        self.fc_zout=nn.Linear(8,48)
        
        

    def forward(self,x):
        x = x.view(-1, 48)
        #print("x.shapein ultima",x.shape)
        K=self.fc_k(x)
        Q=self.fc_q(x)
        V=self.fc_v(x)
        #print("Q<K<V",Q.shape,K.shape,V.shape)
        
        #scale=np.sqrt(8)
        AM=torch.softmax(torch.matmul(Q.T,K)/self.scale,dim=-1)
        #print(AM.shape)
        Z=torch.matmul(V,AM)
        #print("Z",Z.shape)
        out=self.fc_zout(Z)
        #print("out shape",out.shape)
        return out
        

class UltimusModel(nn.Module):

    def __init__(self,device):


        super(UltimusModel, self).__init__()
    
        self.convblock1 = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1),  
            nn.ReLU(),
            nn.BatchNorm2d(16),
            nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3,padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(32),
            nn.Conv2d(in_channels=32, out_channels=48, kernel_size=3,padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(48)
           
        )
        
        self.gap = nn.Sequential(
            nn.AdaptiveAvgPool2d(1)
        ) 

        self.ultimus1=nn.Sequential(
            Ultimus(device)
        )
        
        self.ultimusLayer2=nn.Sequential(
            Ultimus(device)
        )
        
        self.ultimus3=nn.Sequential(
            Ultimus(device)
        )
        
        self.ultimus4=nn.Sequential(
            Ultimus(device)
        )
        

        self.fc = nn.Sequential(
             nn.Linear(48, 10)
        )

        

    def forward(self, x):

        x = self.convblock1(x)
        x = self.gap(x)
        x = self.ultimus1(x)
        x = self.ultimus2(x)
        x = self.ultimus3(x)
        x = self.ultimus4(x)
        x=self.fc(x)
        return x
